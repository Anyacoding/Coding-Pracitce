class Solution {
public:
    int findMin(vector<int>& nums) {
        if (nums.size() == 1)
        return nums[0];
        int l = 0, r = nums.size() - 1;
        int min = 5001;
        //首先明白规律，选择数组最终可分为两个有序数组，且前一个数组的每一个元素都大于等于后一个数组的元素
        //例如[4,5,6,7,0,1,4]
        //当然，也有可能旋转数组是完全升序的，说明没有第二个数组 
        //例如[0,1,4,4,5,6,7]
        //关键是找到分界点，即第二个数组的第一个元素即是最小值
        //或者只有一个数组时，第一个元素就是最小值
        while (l < r) {
            int mid = (l + r) / 2;
            if (nums[mid] > nums[r]) {
                //说明mid前面都是排好序的，分界点在mid的后面
                //所以缩小区间继续查找
                l = mid + 1;
            } else if (nums[mid] < nums[r]) {
                //说明mid后面的元素都是排好序的，分界点在mid前面。也有可能是mid本身
                r = mid;
            } else {
                //此时nums[mid] == nums[r]，分界点即可能在前面也可能在后面
                //例如[3,3,3,2,3]和[2,3,3,3,3]
                //虽然判断结果一样，但是分界点位置不同
                //此时可以--r，他的内在逻辑是mid上的元素与他相同，即使忽略掉也不会发生丢失最小值的情况
                --r;
            }
        }
        return nums[l];
    }
};
